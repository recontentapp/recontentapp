import { globSync } from 'glob'
import { writeFileSync } from 'fs'
import path from 'path'
import { JSONSchema, compile } from 'json-schema-to-typescript'
import { parse } from 'path-to-regexp'

import { RoutesCollection, Route } from '../src/routing-types'

const FILE_NAME = 'routes.ts'
const EXPORT_FILE_NAME = 'routing.ts'

interface File {
  default: RoutesCollection
}

const toInterfaceName = (str: string, suffix: string = '') => {
  return (
    str
      .replace(/\w\S*/g, txt => {
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase()
      })
      .replace(/\s+/g, '') + suffix
  )
}

const routeToJsonSchema = (routePath: string, route: Route): JSONSchema => {
  const pathParams = parse(routePath)
  const requiredPathParams = pathParams
    .filter(token => {
      if (
        typeof token === 'string' ||
        token.modifier === '?' ||
        token.modifier === '*'
      ) {
        return false
      }

      return true
    })
    .map(token => {
      if (typeof token === 'string') {
        return token
      }

      return String(token.name)
    })

  const required: string[] = []

  if (requiredPathParams.length > 0) {
    required.push('pathParams')
  }

  if (Object.values(route.queryParams ?? {}).some(val => val.required)) {
    required.push('queryParams')
  }

  return {
    type: 'object',
    additionalProperties: false,
    properties: {
      pathParams: {
        type: 'object',
        properties: pathParams.reduce((acc, token) => {
          if (typeof token !== 'string') {
            acc[token.name] = { type: 'string' }
          }

          return acc
        }, {}),
        required: requiredPathParams,
      },
      queryParams: {
        type: 'object',
        properties: Object.entries(route.queryParams ?? {}).reduce(
          (acc, [key, params]) => {
            acc[key] = {
              type: params.type,
              ...(params.enum && { enum: params.enum }),
            }

            return acc
          },
          {},
        ),
        required: Object.entries(route.queryParams ?? {})
          .filter(([, params]) => params.required)
          .map(([key]) => key),
      },
    },
    required,
  }
}

const typescriptInterfaceFromJSONSchema = async (
  jsonSchema: JSONSchema,
  interfaceName: string,
): Promise<string> => {
  const result = await compile(jsonSchema, interfaceName, {
    bannerComment: '',
  })

  return result.replace(
    /\[k: string\]: unknown;/g,
    '[k: string]: string | undefined;',
  )
}

const isFileValid = (file: unknown): file is File => {
  if (typeof file !== 'object' || !file) {
    return false
  }

  if (!('default' in file)) {
    return false
  }

  if (typeof file.default !== 'object') {
    return false
  }

  return true
}

interface BuilderRoute {
  name: string
  path: string
  metadata?: Route['metadata']
  interface: {
    name: string
    declaration: string
  }
}

/**
 * Generate a JS object to easily redirect to routes
 * by ensuring proper params are passed
 */
const run = async () => {
  const srcFolder = path.resolve(__dirname, '..', 'src')
  const routingFiles = globSync(`**/${FILE_NAME}`, { cwd: srcFolder })

  const routes: Record<string, BuilderRoute> = {}

  for (const file of routingFiles) {
    const result = await import(path.resolve(srcFolder, file))
    if (!isFileValid(result)) {
      console.error(`Invalid file: ${file}`)
      continue
    }

    for (const [routePath, routeDefinition] of Object.entries(result.default)) {
      if (routes[routePath]) {
        console.error(`Duplicate route: ${routePath}`)
        continue
      }

      const jsonSchema = routeToJsonSchema(routePath, routeDefinition)
      const interfaceName = toInterfaceName(routeDefinition.name, 'Params')
      const compiledInterface = await typescriptInterfaceFromJSONSchema(
        jsonSchema,
        interfaceName,
      )

      routes[routePath] = {
        name: routeDefinition.name,
        path: routePath,
        metadata: routeDefinition.metadata,
        interface: {
          name: interfaceName,
          declaration: compiledInterface,
        },
      }
    }
  }

  const output: string[] = [
    '// This file is autogenerated, do not edit directly.',
    `import { generatePath } from 'react-router-dom'`,
    `import QueryString from 'query-string'`,
    '',
  ]

  output.push(
    ...Object.values(routes).map(route => route.interface.declaration),
  )

  output.push('const routes = {')

  for (const route of Object.values(routes)) {
    output.push(`  ${route.name}: {`)
    output.push(`    url: (params: ${route.interface.name}) => {`)
    output.push(
      `      const path = generatePath('${route.path}', params.pathParams)`,
    )
    output.push(
      `      const queryParams = params.queryParams ? QueryString.stringify(params.queryParams) : undefined`,
    )
    output.push(
      `      return queryParams ? \`\${path}?\${queryParams}\` : path`,
    )
    output.push(`    },`)
    output.push(`    path: ${JSON.stringify(route.path)},`)
    output.push(`    metadata: ${JSON.stringify(route.metadata ?? {})},`)
    output.push(`  },`)
  }

  output.push('}')
  output.push('', 'export default routes', '')

  writeFileSync(path.resolve(srcFolder, EXPORT_FILE_NAME), output.join('\n'))
}

void run()
